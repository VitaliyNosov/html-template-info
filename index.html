<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Libary</title>
    <link rel="stylesheet" href="style/normalize.css">
    <link rel="stylesheet" href="style/prism.css">
    <link rel="stylesheet" href="style/overlayScrollbars.css">
    <link rel="stylesheet" href="style/style.css">
</head>
<body>
    <div class="warapper">
        <div class="container">
            <div class="header">
                <div class="menu">
                    <ul>
                        <li class="pink">
                            <a class="go_to" href="#elm">http</a>
                        </li>
                        <li class="blue">
                            <a class="go_to" href="#elm-2">
                                php
                            </a>
                        </li>
                        <li class="blue-two">
                            <a class="go_to" href="#elm-3">word press</a>
                        </li>
                        <li class="green">
                            <a class="go_to" href="#elm-4">rest api</a>
                        </li>
                        <li class="orange">
                            <a class="go_to" href="#elm-5">java script</a>
                        </li>
                        <li class="blue-three">
                            <a class="go_to" href="#elm-6">css</a>
                        </li>
                        <li class="orange-two">
                            <a class="go_to" href="#elm-7">html</a>
                        </li>
                        <li class="blue">
                            <a class="go_to" href="#elm-8">mysql</a>
                        </li>
                        <li class="orange">
                            <a class="go_to" href="#elm-9">ajax</a>
                        </li>
                        <li class="blue-two">
                            <a class="go_to" href="#elm-10">json</a>
                        </li>
                        <li class="blue-three">
                            <a class="go_to" href="#elm-11">oоп</a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="container">
            <div class="block-info">
                <div class="text">
                    <span class="text-pink">ш</span>
                    <span class="text-blue">п</span>
                    <span class="text-blue-two">а</span>
                    <span class="text-green">р</span>
                    <span class="text-orange">г</span>
                    <span class="text-blue">а</span>
                    <span class="text-orange-two">л</span>
                    <span class="text-blue">к</span>
                    <span class="text-orange">а</span>
                </div>
                <span>для собеседования</span>
            </div>
            <div class="content" id="elm">
                <div class="block">
                    <p class="p-pink">
                        <span class="pink">TCP</span> - то криптографический протокол, позволяющий создавать доказательство факта существования электронного документа на определённый момент времени.
                            «Штамп времени» (англ. time-stamp) — это документ, подписанный электронной подписью (ЭП).
                    </p>
                    <ul>
                        <li>1) Этот протокол позволяет с 100% вероятностью передать данные, если маршрут был нарушен он выберет другой .</li>
                        <li>2) Данные отправляет потоками.</li>
                        <li>3) Одна информация которая делиться на пакеты.</li>
                        <li>4) Выбирает максимально короткий путь передачи информации за счет пакетов и алгоритмов передачи.</li>
                    </ul>
                    <p class="p-pink">
                        <span class="pink">HTTP</span> - это надстройка  над протоколом TCP . 
                        <span class="pink">HTTP</span> -  это протокол передачи гипер-текста ( html ) 
                        Технология <span class="pink">DNS</span> -  позволяет прикрепит доменное имея к определенному сайту. 
                        Доменные зоны: live.vitaliynosov.com
                    </p>
                    <ul>
                        <li>1) live - это под домен 3 уровня</li>
                        <li>2) vitaliynosov - это домен 2 уровня</li>
                        <li>3) com - это домен 1 уровня</li>
                        <li>4) в конце com технически всегда есть точка это доменная зона 0 уровня</li>
                    </ul>
                    <p class="p-pink">
                        Домены и под домены нужны для фильтрации поисковых систем что позволяет быстро найти 
                        информацию на фоне других доменов.
                    </p>
                    <p class="p-pink">
                        <span class="pink">HTTPS</span> не является отдельным протоколом передачи данных, а представляет собой расширение протокола <span class="pink">HTTP</span>
                        с надстройкой шифрования; передаваемые по протоколу <span class="pink">HTTP</span> данные не защищены, <span class="pink">HTTPS</span> обеспечивает конфиденциальность информации путем ее шифрования;
                        <span class="pink">HTTP</span> использует порт 80, <p><span class="pink">HTTPS — порт 443.</span></p>
                    </p>
                    <p class="p-pink">
                        По умолчанию браузеры общаются с сервером по <span class="pink">HTTP.</span> Чтобы соединение стало безопасным, владелец сайта должен установить SSL-сертификат на хостинг.
                        Когда владелец сайта устанавливает SSL-сертификат, в адресной строке браузера появляется значок замка и <span class="pink">HTTP</span> меняется на <span class="pink">HTTPS.</span> 
                        Это значит, что на сайте безопасно вводить личную информацию.
                    </p>
                    <p class="p-pink">
                        Ошибки <span class="pink">HTTP:</span>  
                    </p>
                        <a class="link-pink" target="_blank" href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP">Список ошибок</a>
                    <p class="p-pink">
                        Методы <span class="pink">HTTP запроса:</span>
                    </p>
                    <p class="p-pink">
                        <span class="pink">HTTP</span> определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. 
                        Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. 
                        Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.
                    </p>
                    <ul>
                        <li><p><span class="pink">GET</span> -запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.</p></li>
                        <li><p><span class="pink">HEAD</span> - запрашивает ресурс так же, как и метод GET, но без тела ответа.</p></li>
                        <li><p><span class="pink">POST</span> - используется для отправки сущностей к определённому ресурсу. 
                            Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.</p></li>
                        <li><p><span class="pink" >PUT</span> - заменяет все текущие представления ресурса данными запроса.</p></li>
                        <li><p><span class="pink">DELETE</span> - удаляет указанный ресурс.</p></li>
                        <li><p><span class="pink" >CONNECT</span> - устанавливает "туннель" к серверу, определённому по ресурсу.</p></li>
                        <li><p><span class="pink">OPTIONS</span> - используется для описания параметров соединения с ресурсом.</p></li>
                        <li><p><span class="pink">TRACE</span> - выполняет вызов возвращаемого тестового сообщения с ресурса.</p></li>
                        <li><p><span class="pink">PATCH</span> - используется для частичного изменения ресурса.</p></li>
                    </ul>
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-2" >
                <div class="block">
                    <a href="https://metanit.com/php/tutorial/2.3.php">Источник</a>
                    <h1>PHP - Hypertext Preprocessor — «PHP: препроцессор гипертекста»</h1>
                    <p class="p-blue">
                        PHP является языком с динамической типизацией. Это значит, 
                        что тип данных переменной выводится во время выполнения, 
                        и в отличии от ряда других языков программирования в PHP не надо указывать перед переменной тип данных.
                    </p>
                    <span class="blue">Типы данныx:</span>
                        <ul>
                            <li>bool (логический тип)</li>
                            <li>int (целые числа)</li>
                            <li>float (дробные числа)</li>
                            <li>string (строки)</li>
                            <li>array (массивы)</li>
                            <li>object (объекты)</li>
                            <li>callable (функции)</li>
                            <li>mixed (любой тип)</li>
                            <li>resource (ресурсы)</li>
                            <li>null (отсутствие значения)</li>
                        </ul>
                        <p class="p-blue">
                            Из этих типов данных первые четыре являются скалярными: bool, int, float, string.
                            Поэтому вначале именно их и рассмотрим.
                        </p>
                    </p>
                    <p>
                        <pre class="lang-php">
                            <code>
$num = -100;
echo $num;
                            </code>
                        </pre>
                    </p>
                    <p><span class="blue">Операции:</span></p>
                        <p>asa</p>
                    <p><span class="blue">Конструкция if..else и тернарная операция:</span></p>
                        <p></p>
                    <p><span class="blue">Конструкции switch и match:</span></p>
                        <p></p>
                    <p><span class="blue">Циклы:</span></p>
                        <p></p>
                    <p><span class="blue">Массивы:</span></p>
                        <p></p>
                    <p><span class="blue">Ассоциативные массивы:</span></p>
                        <p></p>
                    <p><span class="blue">Многомерные массивы:</span></p>
                        <p></p>
                    <p><span class="blue">Функции:</span></p>
                        <p></p>
                    <p><span class="blue">Параметры функции:</span></p>
                        <p></p>
                    <p><span class="blue">Возвращение значений и оператор return:</span></p>
                        <p></p>
                    <p><span class="blue">Анонимные функции:</span></p>
                        <p></p>
                    <p><span class="blue">Замыкания / Closure:</span></p>
                        <p></p>
                    <p><span class="blue">Стрелочные функции:</span></p>
                        <p></p>
                    <p><span class="blue">Генераторы:</span></p>
                        <p></p>
                    <p><span class="blue">Ссылки:</span></p>
                        <p></p>
                    <p><span class="blue">Область видимости переменной:</span></p>
                        <p></p>
                    <p><span class="blue">Константы:</span></p>
                        <p></p>
                    <p><span class="blue">Проверка существования переменной:</span></p>
                        <p></p>
                    <p><span class="blue">Получение и установка типа переменной. Преобразование типов:</span></p>
                        <p></p>
                    <p><span class="blue">Операции с массивами:</span></p>
                        <p></p>
                    <p><span class="blue">Супер глобальные массивы( POST, GET ), Cookie:</span></p>
                    <a target="_blank" href="https://ru.wikipedia.org/wiki/Cookie">Читать что такое COOKIE</a>
                    <p>
                        <pre class="lang-php">
                            <code>


// $_GET - содержит в себе GET параметры, это данные которые мы пробрасывает на сервер через строку запроса
// Строка браузера, это и есть порт GET запроса. 

// $_POST - содержит в себе POST параметры, это данные которые мы пробрасываем в теле http документа.

// $_FILES - предоставляет удобный интерфейс для закгруженых файлов.

// $_COOKIE - предоставляет работу с кукисами. 

// $_SESSION - Массив для работы с сессиями.

// $_REQUEST - хранит информацию при переходе между страницами. 

// $_SERVER - содержит информацию о скрипте и серевере.

// $GLOBALS - содержит все переменые со всех глобальных массивов. 

// Функции работы с COOKIE Важно! COOKIE в написании скриптов записываються в самом начале кода.

// В браузере работу COOKIE можно посмотреть в панели разработчика в разделе Application

// 1 - setcookie()

setcookie('test', plus());

echo "Счетчик посещений сервера/страниц {$_COOKIE['test']}";

function plus() {
    if(issets ($_COOKIE['test'])) {
        $_COOKIE['test']++;
    }else{
        $_COOKIE['test'] = 1;
    }
    resturn $_COOKIE['test'];
}


                          </code>
                        </pre>
                    </p>
                    <p></p>
                    <p><span class="blue">Cессия:</span></p>
                    <p class="p-blue">Сессия это единое посищение пользователя, все что он делает о время посищения находясь на одном доменное
                       сайте переходя по страницам это являеться некой сессией c продолжительностью какого то времени.
                       Индификация сессии проходит уникально для каждого пользователя, которому присваиваеться определенны id.
                       Так называемы sid - сессионнный индификатор. Который передаеться так же через кукис.

                       Недостатком сесии относиться контроля жизни, так как время задаеться в конфигаруционном файле init. 
                       На каждом сервере можно настроить файл init на свое усмотрение.

                       Отличие сесии от куки. 

                       Куки храняться в браузере пользователя. 
                       Сессии храняться на стороне сервера.

                       Куки хранят информации которая оноситься к конкретному пользователю, личные настройки,логины и пароли и тд..
                       Сесиии хранят данные на сервере и вреям хранения данных определяет администратор сервера. 
                       Сессии обычно используют для коротко временных задач 1-2 часа, потом дынные удаляються. Храняться данные о 
                       всех посетителях в целом.
                    </p>
                    <p>
                        <pre class="lang-php">
                            <code>
// Перед тем как начать работу с сесиией на браузер пользуваетеля уставливаються уникальные куки с id сесии, а на сервере
// создаеться файл с данными сесии. 

// В супер глобальный массив предавть сириализованые данные не рекомендуеться. Так как эти данные в процессе
// и так автоматически проходят сериализацию. В последствии двойная сириализация может привести к не возможности
// востановлени данных.

// Сериализация — процесс перевода структуры данных в последовательность байтов. Обратной к операции сериализации 
// является операция десериализации — создание структуры данных из битовой последовательности. 
// Сериализация используется для передачи объектов по сети и для сохранения их в файлы.

// Функция session_start(); после инициализации сесии мы можем работать с супер глобальным массивом $_SESSION
// так как и в случае с куками пишем все в начале документа в верху.

session_start();

$_SESSION['Vitaliy'] = 'Vitaliy';
$_SESSION['arr'] = [1, '2', 'test'];

echo 'Ceccии';

echo '<pre>';
print_r($_SESSION);
echo '</pre>';

// Можем точечно удалить элемент из массива сесии через метод unset();

unset($_SESSION['name']);

// Для полного прерывания сессии есть метод session_destroy(); При этом полученые до этого данные 
// остануться на сервере. Таким образом мы просто останвливаем сессию.

// Для удаления сесии и файлов на сервере нам нужно передать сессию с пустым массивом. $_SESSION = [];
// При таком подходе мы прервем сесию и удалим данные на сервере. Но куки которые относятся к этой сесии
// у пользователя остануться в браузере. 

// Для удаления куков есть скрипт который может это сделать: 
// Данный скрипт нужно запускать до какого либо echo, то есть до вывода чего либо на сраницу.

if(ini_get("session.use_cookies")){
    $params = session_get_cookie_params();
    setcookie(session_name(), '', time() - 42000,
        $params["path"], $params["domain"],
        $params["secure"], $params["httponly"],
    
    );
}

echo '<pre>';
print_r($_SESSION);
echo '</pre>';

                            </code>
                        </pre>
                    </p>
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-3">
                <div class="block">
                    <h1>
                        WordPress — система с открытым исходным кодом; написана на PHP. 
                    </h1>
                    <p class="p-blue-two"><span class="blue-two">Хуки:</span></p>
                    <h3>Хуки: это Filter и Action</h3>
                    <h4>Отличие Filter от Action это коблек функция.</h4>
                    <p class="p-blue-two">
                        <span class="bold">Action:</span> запускает произвольный код — кол-бэк функция прикрепленный к хуку сработает в момент срабатывания хука в коде.
                    </p>
                    <p class="p-blue-two">
                        Что такое кол-бек функция - функция обратного вызова 
                        (часто называемая просто "callback") — это функция, 
                        которая передается в качестве аргумента другой функции.
                    </p>
                    <p class="p-blue-two">
                        <span class="bold">add_action()</span> - добавляет/прикрепляет функции к событию.</br>
                        <span class="bold">do_action()</span> - вызывает эту функцию.
                    </p>
                    <p class="p-blue-two">
                        <span class="bold">Filter:</span> Изменяет значение переменной — получает значение и возвращает его (изменённое или нет).
                    </p>
                    <p class="p-blue-two">
                        <span class="bold">add_filter( hook_name, function, priority, args_num )</span> — добавляет/прикрепляет функцию к фильтру,                    
                        которая будет вызвана в момент срабатывания фильтра. Такая функция называется «коллбэк-функция».
                    </p>
                    <p class="p-blue-two">
                        <span class="bold">apply_filters( hook_name, value, args... )</span> — создает хук-фильтр. Запускает прикрепленные к фильтру коллбэк-функцию.
                    </p>
                    <h3>
                        Пример:
                    </h3>
                    <p>
                        <pre class="lang-php">
                            <code>
// Активный класс меню

    add_filter('nav_menu_css_class' , 'special_nav_class' , 10 , 2);

        function special_nav_class ($classes, $item) {
            if (in_array('current-menu-item', $classes) ){
                $classes[] = 'active ';
                    }
                    return $classes;
            }
                            </code>
                        </pre>
                    </p>
                    
                    <span class="blue-two">Таксаномии:</span>
                    <p class="p-blue-two">
                        <span class="bold">Таксаномии</span> - это рубрики.
                    </p>
                    <p class="p-blue-two">
                        Сначала нужно регистрировать таксономию, а потом тип записи с которым эта таксономия связана!
                    </p>
                    <p>
                        <pre class="lang-php">
                            <code>
// правильный порядок регистрации типа записи и её таксономии
    register_taxonomy( ... );
        register_post_type( ... );

// функцию желательно вызывать во время события init:

add_action( 'init', 'function_name' );
                            </code>
                        </pre>
                    </p>
                    <span class="blue-two">Custome Post Type:</span>
                    <p class="p-blue-two">
                        Функция регистрации нового типа записи: <span class="bold">register_post_type()</span>
                    </p>

                    <span class="bold">Custome Post Type</span> - это новый тип записи.  Создает новый тип записи или изменяет имеющийся.   

                    <span class="blue-two">Виджеты:</span>
                    <p class="p-blue-two">
                        <span class="bold">Виджеты WordPress</span> - являются частью  элемента WordPress, 
                        который выполняет одну конкретную функцию: добавление дополнительного содержимого и структуры на 
                        боковую панель или нижний колонтитул. Например, виджеты могут отображать ваши последние сообщения, 
                        календарь, панель поиска и многое другое.
                    </p>
                    <p class="p-blue-two">
                        Функция регистрации нового виджета - <span class="bold">register_widget()</span>
                    </p>
                    <span class="blue-two">Шорткод:</span>
                    <p class="p-blue-two">
                        <span class="bold">Шорткод</span> - это конструкция в тексте, которая будет обработана и заменена на указанный код/текст. 
                        Обрабатывается шор-ткод специальной PHP функцией, указанной при регистрации шорт-кода.
                    </p>
                    <h3>Пример:</h3>
                    <p>
                        <pre class="lang-php">
                            <code>
//функция создания:

    add_shortcode() 

//функция вывода в шаблоне:

    do_shortcode( '[about-slider-one]' )

//вывод в редакторе: название шорт-кода [шорт-код]
                            </code>
                        </pre>
                    </p>
                    <span class="blue-two">Мультисайт:</span>
                    <p class="p-blue-two">
                        <span class="bold">Мультисайт</span> - это такой вариант конфигурации WP, 
                        который позоляет вам использовать неограниченное количество сайтов в пределах одной-единственной 
                        установки WordPress и управлять всеми этими сайтами как суперадминистратор.
                    </p>
                    <p class="p-blue-two">
                        <span class="bold">Настройка:</span>
                    </p>
                    <p class="p-blue-two">
                        Откройте конфигурационный файл WordPress wp-config.php, 
                        который лежит в корне вашего сайта или на одну директорию выше 
                        (для этого может понадобиться подключиться по FTP) и найдите следующую строку:
                    </p>
                    <p>
                        <pre class="lang-php">
                            <code>
require_once( ABSPATH . 'wp-settings.php' );

    //в любом месте до этой строки вставьте следующую директиву, 
    //которая включает возможность установки режима Multisite:

    //включение режима WordPress Мультисайт

define( 'WP_ALLOW_MULTISITE', true );
                            </code>
                        </pre>
                    </p>
                        <span class="bold">Подробнее:</span>
                        <a target="_blank" href="https://misha.agency/wordpress/multisite.html#:~:text=WordPress%20%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D1%81%D0%B0%D0%B9%D1%82%20%E2%80%93%20%D1%8D%D1%82%D0%BE%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B9%20%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82,%D0%B2%D1%81%D0%B5%D0%BC%D0%B8%20%D1%8D%D1%82%D0%B8%D0%BC%D0%B8%20%D1%81%D0%B0%D0%B9%D1%82%D0%B0%D0%BC%D0%B8%20%D0%BA%D0%B0%D0%BA%20%D1%81%D1%83%D0%BF%D0%B5%D1%80%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%BE%D1%80.">Читать</a>
                        <span class="blue-two">WP CLI:</span>
                    <p class="p-blue-two">
                        <span class="bold">WP CLI</span> - это интерфейс командной строки для WordPress. 
                        Он позволяет устанавливать/обновлять/удалять темы и плагины, 
                        создавать и просматривать любые данные на сайте, изменять настройки сайта и многое другое. 
                        Все это делается из командной строки без использования браузера.
                    </p>
                    <span class="bold">Подробнее:</span>
                    <a target="_blank" href="https://code.tutsplus.com/ru/tutorials/what-is-wp-cli-a-beginners-guide--cms-28649">Читать</a>
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-4">
                <div class="block">
                    <h1>REST API — это способ взаимодействия сайтов и веб-приложений с сервером. Его также называют RESTful.</h1>
                    <p class="p-green">
                        Термин состоит из двух аббревиатур, которые расшифровываются следующим образом. 
                        API (Application Programming Interface) — это код, который позволяет двум приложениям обмениваться данными с сервера.
                        На русском языке его принято называть программным интерфейсом приложения. 
                        REST (Representational State Transfer) — это способ создания API с помощью протокола HTTP. 
                        На русском его называют «передачей состояния представления».
                    </p>
                    <ul>
                        <li>
                            <span class="green">Отделения клиента от сервера (Client-Server)</span>
                        </li>
                            </br>
                            <p class="p-green">
                                Клиент — это пользовательский интерфейс сайта или приложения, например, поисковая строка видеохостинга. 
                                В REST API код запросов остается на стороне клиента, а код для доступа к данным — на стороне сервера.
                                Это упрощает организацию API, позволяет легко переносить пользовательский интерфейс на другую 
                                платформу и дает возможность лучше масштабировать серверное хранение данных.
                            </p>
                        <li>
                            <span class="green">Отсутствие записи состояния клиента (Stateless)</span>
                            <p class="p-green">
                                Сервер не должен хранить информацию о состоянии (проведенных операций) клиента. 
                                Каждый запрос от клиента должен содержать только ту информацию, которая нужна для получения данных 
                                от сервера.
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="green">Кэшируемость (Casheable)</span>
                            <p class="p-green">
                                В данных запроса должно быть указано, нужно ли кэшировать данные (сохранять в специальном буфере для частых запросов). 
                                Если такое указание есть, клиент получит право обращаться к этому буферу при необходимости.
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="green">Единство интерфейса (Uniform Interface)</span>
                            <p class="p-green">
                                Все данные должны запрашиваться через один URL-адрес стандартными протоколами, например, HTTP. 
                                Это упрощает архитектуру сайта или приложения и делает взаимодействие с сервером понятнее.
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="green">Многоуровневость системы (Layered System)</span>
                            <p class="p-green">
                                В RESTful сервера могут располагаться на разных уровнях, при этом каждый сервер взаимодействует 
                                только с ближайшими уровнями и не связан запросами с другими.
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="green">Предоставление кода по запросу (Code on Demand)</span>
                            <p class="p-green">
                                Серверы могут отправлять клиенту код (например, скрипт для запуска видео). 
                                Так общий код приложения или сайта становится сложнее только при необходимости.
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="green">Начало от нуля (Starting with the Null Style)</span>
                            <p class="p-green">
                                Клиент знает только одну точку входа на сервер. 
                                Дальнейшие возможности по взаимодействию обеспечиваются сервером.
                            </p>
                        </li>
                    </ul>
                    <ul>
                        <p class="p-green">
                            В REST API есть 4 метода HTTP, которые используют для действий с объектами на серверах:
                        </p>
                        <li>
                            <span class="green">
                                GET (получение информации о данных или списка объектов)
                            </span>
                        </li>
                            </br>
                        <li>
                            <span class="green">
                                DELETE (удаление данных)
                            </span>
                        </li>
                            </br>
                        <li>
                            <span class="green">
                                POST (добавление или замена данных)
                            </span>
                        </li>
                            </br>
                        <li>
                            <span class="green">
                                PUT (регулярное обновление данных)
                            </span>
                        </li>
                    </ul>  
                    <h2>Пример работы с REST API на языке PHP c помощбю метода curl:</h2>
                    <p>
                        <pre class="lang-php">
                            <code>
// Видео пример: https://www.youtube.com/watch?v=NYUpB_wqAwE

// Мануал: https://www.php.net/manual/ru/book.curl.php

// https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json

$url = "https://jsonplaceholder.typicode.com/users/1";
// $url = "https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json";

$ch = curl_init();
curl_setopt($ch, CURLOPT_HTTPHEADER, array('Content-Type:application/json'));
curl_setopt($ch, CURLOPT_URL, $url);
curl_setopt($ch, CURLOPT_POST, 0);
// curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($data, JSON_UNESCAPED_UNICODE)); 
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);
curl_setopt($ch, CURLOPT_TIMEOUT, 10);
curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
// curl_setopt($ch, CURLOPT_HEADER, false);
$response = curl_exec($ch);

curl_close($ch);
 
// json_decode() - преобразут данные в обьект

// $obj_response = json_decode($response);

// json_decode( , true) - преобразут данные в массив

$obj_response = json_decode($response, true);

// var_dump($obj_response);

// Выводим в красивом виде обьект который мы получаем по api

$rep = print_r($obj_response, true);
echo '<pre>' . htmlentities($rep) . '</pre>';

// Выводи клюди обьекта в строку:

// echo $obj_response->name .''
//     .$obj_response->username .'' , ' , ' 
//     .$obj_response->email .'' , ' , ' 
//     .$obj_response->address->street .'' , ' , '
//     .$obj_response->address->suite .'' , ' , '
//     .$obj_response->address->city .'' , ' , '
//     .$obj_response->address->zipcode .'' , ' , '
//     .$obj_response->address->geo->lat .'' , ' , '
//     .$obj_response->address->geo->lng .'' , ' , '
//     .$obj_response->phone .'' , ' , '
//     .$obj_response->website .'' , ' , '
//     .$obj_response->company->name .'' , ' , '
//     .$obj_response->company->catchPhrase .'' , ' , '
//     .$obj_response->company->bs .'' 
// ;

?>

<div class="container">

<?php

// Выводим циклом массив данных:

foreach ($obj_response as $name => $items)

{   echo "<ul>";
        echo "<h3>$items</h3>";
    
        if(is_array($items)){
        // Выполняем проверку являеться ли items массивом

        foreach ($items as $key => $value)
        {
            echo "<li>$key : $value</li>";
        }
            echo "</ul>";
    }

}

// Для красоты подключем стили:)
echo "<link rel='stylesheet' href='style.css'>";

?>

</div>

                            </code>
                        </pre>
                    </p>
                        </br>
                        <h2>Пример работы с REST API на языке JAVA SCRIPT:</h2>
                        <p>
                            <pre class="lang-javascript">
                                <code>
// https://developer.mozilla.org/ru/docs/Learn/JavaScript/Client-side_web_APIs/Introduction

// JSON: 
                                    
// https://developer.mozilla.org/ru/docs/Learn/JavaScript/Objects/JSON
                                    
// Metod: fetch() 
                                    
// https://developer.mozilla.org/ru/docs/Web/API/Fetch_API/Using_Fetch
                                    
// Metod: map()
                                    
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map
                                    
// Metod: join()
                                    
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/join
                                    
// Operator: return 
                                    
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return
                                    
                                    
                                    
    fetch(
        'https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json')
    .then((res) => res.json()
    .then(data => setHeroes(data, console.log(data) ))
                                    
    ;
                                    
                                    
    function setHeroes({ squadName, homeTown, formed, members }) {
        document.body.insertAdjacentHTML(
            'afterbegin',
                `
                <h1>${squadName}</h1>
                <h2>Hometown: ${homeTown} //Formated: ${formed}</h1>
                <div class="heroes">${setMembers(members)}</div>
                `
                );
            }
                                    
                                    
    function setMembers(members) {
        return members.map(
            (hero) => 
                                            
                `
                <div>
                    <h3>${hero.name}</h3>
                    <p class="secret">Secret identity: ${hero.secretIdentity}</p>
                    <p>Age: ${hero.age}</p>
                    <p>Superpower: </p>
                        <ul>
                            ${hero.powers.map((power) => `<li>${power}</li>`).join('')}
                        </ul>
                    </div>
                `
                ).join('');
            }
    
                                </code>
                            </pre>
                        </p>             
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-5" >
                <div class="block">
                    <h1>JavaScript — мультипарадигменный язык программирования. 
                        Поддерживает объектно-ориентированный, императивный и функциональный стили. 
                        Является реализацией спецификации ECMAScript. 
                    </h1>
                    <ul>
                        <li>
                            <span class="orange">Типы данных</span>
                        </li>
                        <p class="p-orange">
                            Стандарт ECMAScript определяет 8 типов:
                        </p>
                        <ul>
                            <li><span class="bold">Undefined</span> (Неопределённый тип)  : typeof instance === "undefined"</li>
                            <li><span class="bold">Boolean</span> (Булев, Логический тип) : typeof instance === "boolean"</li>
                            <li><span class="bold">Number</span> (Число) : typeof instance === "number"</li>
                            <li><span class="bold">String</span> (Строка) : typeof instance === "string"</li>
                            <li><span class="bold">BigInt</span>  : typeof instance === "bigint"
                                BigInt является встроенным объектом, который предоставляет способ представления целых чисел, которые больше 2 53, 
                                что является наибольшим числом, которое JavaScript может надёжно представить с помощью Number примитива.
                            </li>
                            <li><span class="bold">Symbol</span> (в ECMAScript 6)  : typeof instance === "symbol"Символ — это уникальное и иммутабельное примитивное значение, 
                                которое может быть использовано как ключ для свойства объекта (смотрите ниже). 
                                В некоторых языках программирования символы называются атомами. </li>
                            <li><span class="bold">Null</span> (Null тип ) : typeof instance === "object". Специальный примитив, 
                                используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;</li>
                            <li><span class="bold">Object</span> (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, 
                                но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: 
                                new Object, new Array, new Map (en-US), new Set, new WeakMap, new WeakSet, 
                                new Date и множество других структур;</li>
                        </ul>
                            </br>
                        <li>
                            <span class="orange">Обьявление переменной:</span>
                            <p class="p-orange">Области видимости</p>
                            <ul>
                                <li><span class="bold">var</span> - она являться глобальной, она может быть локальной если мы ее обьвем в нутри какого-то метода
                                    Обьявление переменной при вызове встплывает в самый вверх.
                                </li>
                                <li><span class="bold">let</span> - обладает блочной областью видемости то есть она являеться локальной.
                                    Обьявление переменной при вызове не встплывает в самый вверх.
                                </li>
                                <li><span class="bold">const</span> - при обределении мы не может переопределить нашу переменную, она являеться костантой.</li>
                            </ul>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Функции</span>
                        </li>
                        <p>
                            <pre class="lang-javascript">
                                <code>
// Функция (старый синтаксис)      

var sum = function(a, b) {
    return a + b;
}

// Стрелочная функция: 

const sum = (a, b) => {
    return a + b;
}

// Сокращеный вариант, если в теле функции уна только одна строчка

const sum = (a, b) =>  a + b;

// Стрелочная функция с одним параметром, скобки можно не писать

const squere = num => num * num;

// Cтрелочная функция если параметров нет

const printHello = () => {
    console.log('hello');
}


                                </code>
                            </pre>
                        </p>
                        <p class="p-orange">
                            Выражения стрелочных функций имеют более короткий синтаксис по сравнению с функциональными выражениями и лексически привязаны к значению 
                            this (но не привязаны к собственному this, arguments, super, или new.target). 
                            Выражение стрелочных функций не позволяют задавать имя, поэтому стрелочные функции анонимны, если их ни к чему не присвоить.
                        </p>
                            </br>
                        <li>
                            <span class="orange">Оператор многоточие ... (он же spread, он же rest)</span>
                        </li>
                        <p class="p-orange">
                            Оператор ... позволяет расширить доступные для итерации элементы (например, массивы или строки) в местах:
                            для функций: где ожидаемое количество аргументов для вызовов функций равно нулю или больше нуля,
                            для элементов (литералов массива),
                            для выражений объектов: в местах, где количество пар "ключ-значение" должно быть равно нулю или больше (для объектных литералов)
                        </p>
                        <p>
                            <pre class="lang-javascript">
                                <code>
// Создадим массив и обьеденим значения двух передыдущих

const number1 = [1,2,3,4,5];
const number1 = [7,8,4,3,2];

const allNumbers = [...numbers1, ...numbers2]; 
                                </code>
                            </pre>
                        </p>
                            </br>
                        <li>
                            <span class="orange">Деструктуризация массивов:</span>
                        </li>
                        <p class="p-orange">
                            Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить… 
                            Деструктуризация объекта.Деструктуризацию можно использовать и с объектами.… 
                            Деструктуризации можно как угодно сочетать и вкладывать друг в друга.… 
                            Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.… 
                            Однако при деструктуризации объекта может потребоваться обернуть выражение в скобки.
                        </p>
                        <p>
                            <pre class="lang-javascript">
                                <code>
const number = [1,2,3,4,5];

// Выполним дейсвие деструктуризации

const [first, second, , ...tail] = numbers;

// По порядку мы получем выбраные значения, если какой то елемент нужно
// пропустить то нужно использовать оператор:  , 
// Если нам нужен остаток то используем spred операт и ключевое слово tail
                                </code>
                            </pre>
                        </p>
                            </br>
                        <li>
                            <span class="orange">Деструктуризация обьектов:</span>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
// Тоже самое мы можем делать но уже с обьктами

const myObj = {
    a: 1,
    b: 2,
    с: 3,
    d: 4,
};

// Передаем просто название ключей

const {d ...tail} = myObj;

// Более сложный пример:

const myObj = {
    a: 1,
    b: 2,
    с: {
        a: 0,
        b: 10,
    },
    d: 4,
};

// Деструктуризация обьекта

const {
    d: myName = 0,
    a: first = 0,
    с: { a: secondA = 0 } = {},
    n: [, deepB = 0] = [],
    ...tail 
} = myObj || {};
                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Колбэки и функции высшего порядка</span>
                            <p class="p-orange">
                                Это такие функции⚙️, которые принимают функцию⚙️ в качестве аргумента или возвращают🔄 функцию⚙️ в качестве вывода.
                            </p>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
// Пример колбек функции

function copyArrayDoSmith(arr, instruction) {
    const output = [];

    for (let i = 0; i < arr.length; i++) {
        output.push(instruction(arr[i]));
    }

    return output;
}

// instruction - это и есть коллбек 

function numSqueared(num) {
    return num * num;
}

function divideBy2(num) {
    return num / 2;
}

const result = copyArrayDoSmith([1,2,3], numSqueared);
const result2 = copyArrayDoSmith([10,20,30], divideBy2);
                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Методы фильтрации массивов</span>
                        </li>
                        <p class="p-orange">
                            <span class="bold">indexOf()</span> - сравнивает искомый элемент searchElement с элементами в массиве.
                                </br>
                            <span class="bold">includes()</span> - определяет, содержит ли массив определённый элемент, возвращая в зависимости от этого true или false.
                                </br>
                            <span class="bold">find()</span> - возвращает значение первого найденного в массиве элемента, которое удовлетворяет условию переданному в callback функции.
                                </br>
                            <span class="bold">findIndex()</span> - возвращает индекс в массиве, если элемент удовлетворяет условию проверяющей функции.
                                </br>
                            <span class="bold">forEach()</span> - выполняет функцию callback один раз для каждого элемента, находящегося в массиве в порядке возрастания.
                                </br>
                            <span class="bold">map()</span> - создаёт новый массив с результатом вызова указанной функции.
                                </br>
                            <span class="bold">filter()</span> - создаёт новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.
                                </br>
                            <span class="bold">reduce()</span> - применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.
                        </p>
                        <p>
                            <pre class="lang-javascript">
                                <code>
const numbers = [1,2,3,4,5];
const lang = ['HTML','CSS','JavaScript','Python','PHP'];

const result = numbers.indexOf(3);
console.log('result', result);
                                </code>
                            </pre>
                        </p>
                            </br>
                        <li>
                            <span class="orange">Рекурсия</span>
                            <p class="p-orange">
                                Рекурсия – это приём программирования, полезный в ситуациях, 
                                когда задача может быть естественно разделена на несколько аналогичных, 
                                но более простых задач. Или когда задача может быть упрощена до несложных действий плюс простой вариант той же задачи. 
                                Или, как мы скоро увидим, для работы с определёнными структурами данных.
                                В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач. 
                                Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.
                            </p>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
// Рекурсию можно сравнить с бесконечным цыклом, что бы для работы
// хватало оперативной памяти нам нужно обязательно писать условие.
// По ходу кода у нас переменная count будет всплывать 5 раз.
// По завершению выполнений функции последовательно оперативная память очиститься из контекста.

let count = 0;

function recurce() {
    if(count === 5) return 'done';

    count++;
    return recurce();
}

console.log(recurce());
console.log('count =', count);
                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Замыкания</span>
                            <p class="p-orange">
                                Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. 
                                Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. 
                                В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
                            </p>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
// 1 Замыкания - это когда функция в нутри себя возвращает новую функцию. 
// 2 Возвращяемые функции помнят контест где были созданы.

function createFn() {
    function greenting() {
        console.log('hello world');
    }

    return greeting;
}

const helloWorld = createFn();

helloWorld();

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Модули</span>
                            <p class="p-orange">
                                Встроенная обработка модулей JavaScript связана с функциями 
                                    <span class="bold">import</span> и 
                                    <span class="bold">export</span>, 
                                которые поддерживаются браузерами.
                            
                            </p>
                            <p class="p-orange">
                                Сначала программы на JavaScript были небольшими — в прежние времена они использовались для изолированных задач, 
                                добавляя при необходимости немного интерактивности веб-страницам, так что большие скрипты в основном не требовались. 
                                Прошло несколько лет, и вот мы уже видим полномасштабные приложения, работающие в браузерах и содержащие массу кода на JavaScript; 
                                кроме того, язык стал использоваться и в других контекстах (например, Node.js).
                                Таким образом, в последние годы появились причины на то, чтобы подумать о механизмах деления программ на JavaScript 
                                на отдельные модули, которые можно импортировать по мере необходимости. Node.js включал такую возможность уже давно, 
                                кроме того, некоторые библиотеки и фреймворки JavaScript разрешали использование модулей 
                                (например, CommonJS и основанные на AMD системы модулей типа RequireJS, а позднее также Webpack и Babel).
                            </p>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
// Код подключаемого файла, hello.js


function sayHello() {
    console.log('hello');
}

module.export = { sayHello };

// Подключение в стороннем файле, поддерживаеться деструктуризация

const { sayHello } = require('./components/hello');

sayHello();


                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">
                                Constructor - Конструктор
                            </span>
                            <p class="p-orange">
                                <span>constructor</span> - это специальный метод, служащий для создания и инициализации объектов, созданных с использованием class.
                                Конструктор позволяет произвести начальную инициализацию, которая должна быть выполнена до того, как остальные методы будут вызваны.
                            </p>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
//Пример конструктора

class Person {

    constructor(name) {
      this.name = name;
    }
  
    introduce() {
      console.log(`Hello, my name is ${this.name}`);
    }
  
  }
  
  const otto = new Person('Отто');
  
otto.introduce();
                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="orange">Promise - Промис</span>
                            <p class="p-orange">
                                Объект <span>Promise</span> используется для отложенных и асинхронных вычислений.
                            </p>
                            <p class="p-orange">
                                Интерфейс <span>Promise</span> (промис) представляет собой обёртку для значения, неизвестного на момент создания промиса. Он позволяет обрабатывать результаты асинхронных операций так, как если бы они были синхронными: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "промис") получить результат в некоторый момент в будущем.
                                <span>Promise</span> может находиться в трёх состояниях:
                            </p>
                            <ul class="p-orange" >
                                <li>ожидание <span>(pending)</span>: начальное состояние, не исполнен и не отклонён.</li>
                                <li>исполнено <span>(fulfilled)</span>: операция завершена успешно.</li>
                                <li>отклонено <span>(rejected)</span>: операция завершена с ошибкой.</li>
                            </ul>
                            <p>
                                <pre class="lang-javascript">
                                    <code>
123                                        
                                    </code>
                                </pre>
                            </p>
                        </li>
                    </ul>
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-6" >
                <div class="block">
                    <h1>
                        CSS (/siːɛsɛs/ англ. Cascading Style Sheets «каскадные таблицы стилей») — формальный язык описания внешнего вида документа (веб-страницы),
                        написанного с использованием языка разметки (чаще всего HTML или XHTML). 
                        Также может применяться к любым XML-документам, например, к SVG или XUL.
                    </h1>

                        <p>Отличие CSS от CSS3</p>

                        <ul>
                            <li>Основное различие между CSS и CSS3 заключается в том, что в CSS3 есть модули. 
                                CSS является базовой версией и не поддерживает адаптивный дизайн. 
                                CSS3, с другой стороны, является последней версией и поддерживает адаптивный дизайн.
                            </li>
                                </br>
                            <li>CSS нельзя разбить на модули, но CSS3 можно разбить на модули. 
                                Быть старой версией CSS медленнее, чем CSS3.
                            </li>
                                </br>
                            <li>В дополнение к этим CSS3 имеет много функций выравнивания. 
                                CSS3 предоставляет инструмент для изменения размеров ячеек, 
                                который позволяет пользователю получить правильный размер любого элемента без каких-либо 
                                изменений в размерах или заполнении элемента. 
                                CSS не имеет какого-либо инструмента для определения размера блоков, 
                                и поэтому пользователю необходимо использовать стандартные процедуры, 
                                определенные для выравнивания текста.
                            </li>
                                </br>
                            <li>Анимации и 3D-преобразования лучше в CSS3. Элементы можно перемещать по экрану с помощью 
                                flash и JavaScript. Используя это, элементы также смогут менять свой размер и цвет. 
                                Все виды переходов, преобразований и анимаций могут быть выполнены с использованием CSS3. 
                                CSS не предоставляет 3D анимацию и преобразования.
                            </li>
                                </br>
                            <li>CSS предоставляет базовую цветовую схему и стандартные цвета. 
                                CSS3 поддерживает цвета RGBA, HSLA, HSL и градиент. 
                                Он также поддерживает закругленные углы изображения для текстовых полей.
                            </li>
                                </br>
                            <li>Многоколонные текстовые блоки могут быть определены в CSS3. 
                                CSS поддерживает только отдельные текстовые блоки.
                            </li>
                        </ul>
                   
                        <p>Что такое модули?</p>

                        <p>
                            CSS-файлы, в которых все классы и анимации по умолчанию находятся в локальной области видимости.
                        </p>

                        <p>
                            CSS-модули — это не официальная спецификация, они не имплементированы в браузеры, скорее, это задача, 
                            запускаемая на стадии сборки проекта (например, с помощью Webpack или Browserify), в процессе выполнения 
                            которой имена классов и селекторы изменяются так, чтобы образовалась своего рода локальная область 
                            видимости (что-то вроде пространства имен).
                        </p>

                        <a href="https://frontender.info/css-modules-part-1-need/" target="_blank">Читать подробнее про модули</a>

                        <p>Псевдокласс</p>

                        <p>
                            Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, 
                            они являются первым элементом своего типа, или на них наведён указатель мыши. Они обычно действуют так, 
                            как если бы вы применили класс к какой-то части вашего документа, что часто помогает сократить избыточные 
                            классы в разметке и даёт более гибкий, удобный в поддержке код.
                        </p>

                        <p>Псевдоэлементы</p>

                        <p>
                            Псевдоэлементы ведут себя сходным образом, однако они действуют так, как если бы вы добавили в разметку 
                            целый новый HTML-элемент, а не применили класс к существующим элементам. 
                            Псевдоэлементы начинаются с двойного двоеточия ::
                        </p>

                        <a target="_blank" href="https://developer.mozilla.org/ru/docs/Learn/CSS/Building_blocks/Selectors/Pseudo-classes_and_pseudo-elements">Читать подробнее про псевдоклассы и псевдоэлементы</a>

                        <p>Потоки</p>

                        <p>Вес класса</p>

                        <a target="_blank" href="https://canonium.com/articles/css-understanding-weight-selectors/">Читать про вес класса</a>


                </div>
            </div>
            <div class="content" id="elm-7">
                <div class="block">
                    
                    <h1>HTML (от англ. HyperText Markup Language — «язык гипертекстовой разметки»)</h1> — стандартизированный 
                        язык разметки документов для просмотра веб-страниц в браузере. 
                    <p> 
                        Веб-браузеры получают <span class="orange-two">HTML</span> документ от сервера по протоколам HTTP/HTTPS или открывают с локального диска, 
                        далее интерпретируют код в интерфейс, который будет отображаться на экране монитора.
                    </p>

                    <p class="p-orange-two"><span class="orange-two">&lt;a&gt;</span> - Определяет гиперссылки</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;abbr&gt;</span> - Определяет аббревиатуру</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;acronym&gt;</span> - Не поддерживается. Определяет акроним</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;address&gt;</span> - Определяет элемент с адресом</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;applet&gt;</span> - Не поддерживается. Определяет апплет</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;area&gt;</span> - Определяет область внутри изображения карты</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;article&gt;</span> - Определяет статью</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;aside&gt;</span> - Определяет контент в стороне от основного контента страницы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;audio&gt;</span> - Определяет аудио контент</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;b&gt;</span> - Определяет жирный текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;base&gt;</span> - Определяет базовый URL для всех относительных ссылок на странице</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;basefont&gt;</span> - Не поддерживается. Используетя вместо CSS для задания шрифта</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;bdo&gt;</span> - Определяет направление отображения текста</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;big&gt;</span> - Не поддерживается. Определяет большой текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;blockquote&gt;</span> - Определяет длинную цитату</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;body&gt;</span> - Определяет элемент тела документа</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;br&gt;</span> - Вставка одного разрыва строки</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;button&gt;</span> - Определяет кнопку</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;canvas&gt;</span> - Определяет графики</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;caption&gt;</span> - Определяет заголовок (подпись) таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;center&gt;</span> - Не поддерживается. Определяет текст по центру</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;cite&gt;</span> - Определяет цитату или сноску на материал</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;code&gt;</span> - Определяет, что текст является программным кодом</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;col&gt;</span> - Определяет атрибуты для столбцов таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;colgroup&gt;</span> - Определяет групп столбцов таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;command&gt;</span> - Определяет командную кнопку</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;datagrid&gt;</span> - Определяет данные в упорядоченный список</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;datalist&gt;</span> - Определяет выпадающий список</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;datatemplate&gt;</span> - Определяет шаблон данных</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dd&gt;</span> - Определяет описание определения</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;del&gt;</span> - Определяет удаленный текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;details&gt;</span> - Определяет детали элемента</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dialog&gt;</span> - Определяет диалог (разговор)</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dir&gt;</span> - Не поддерживается. Определяет список директорий</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;div&gt;</span> - Определяет секцию (блок) в документе</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dfn&gt;</span> - Определяет определение термина</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dl&gt;</span> - Определяет список определений</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;dt&gt;</span> - Определяет определение термина в списке</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;em&gt;</span> - Определяет выделенный текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;embed&gt;</span> - 	Определяет внешний интерактивный контент или плагин</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;eventsource&gt;</span> - Определяет цель события, отправляемого по серверу</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;fieldset&gt;</span> - Определяет сгруппированный набор полей формы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;figure&gt;</span> - Определяет группу медиа-контента, и их подписи</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;font&gt;</span> - Устаревший. Определяет шрифт текста, размер и цвет</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;footer&gt;</span> - Определяет нижний колонтитул для раздела или страницы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;form&gt;</span> - Определяет форму</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;frame&gt;</span> - Не поддерживается. Определяет фрейм</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;frameset&gt;</span> - Не поддерживается. Определяет набор фреймов</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;h1 по h6&gt;</span> - Определяет заголовок с 1 по 6 заголовок</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;head&gt;</span> - Определяет информацию о документе</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;header&gt;</span> - Определяет область заголовка раздела или страницы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;hr&gt;</span> - Определяет горизонтальную линию</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;html&gt;</span> - Определяет html документ</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;i&gt;</span> - Определяет курсив</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;iframe&gt;</span> - Определяет встроенный фрейм</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;img&gt;</span> - Определяет изображение</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;input&gt;</span> - Определяет поле ввода</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;ins&gt;</span> - Определяет вставленный (обновленный) текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;isindex&gt;</span> - Не поддерживается. Определяет поисковый индекс в документе</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;kbd&gt;</span> - Определяет текст, набранный на клавиатуре</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;label&gt;</span> - Определяет метку для элемента формы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;legend&gt;</span> - Определяет заголовок группы элементов формы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;li&gt;</span> - Определяет элемент списка</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;link&gt;</span> - Определяет ссылку на ресурс</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;mark&gt;</span> - Определяет выделенный текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;map&gt;</span> - Определяет изображение карты</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;menu&gt;</span> - Определяет список меню</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;meta&gt;</span> - Определяет мета-информацию</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;meter&gt;</span> - Определяет измерения в течение заранее определенного диапазона</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;nav&gt;</span> - Определяет навигационные ссылки</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;nest&gt;</span> - Определяет вложенную точку в шаблоне данных</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;noframes&gt;</span> - Не поддерживается. Определяет секцию, не поддерживающую фрейм</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;noscript&gt;</span> - Определяет секцию, не поддерживающую сценарий (скрипт)</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;object&gt;</span> - Определяет внедренный объект</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;ol&gt;</span> - Определяет упорядоченный список</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;optgroup&gt;</span> - Определяет группу вариантов в раскрывающемся списке</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;option&gt;</span> - Определяет вариант в раскрывающемся списке</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;output&gt;</span> - Определяет некоторые виды результата</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;p&gt;</span> - Определяет параграф (абзац)</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;param&gt;</span> - Определяет параметр для объекта</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;pre&gt;</span> - Определяет выровненный (форматированный) текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;progress&gt;</span> - Определяет ход выполнения задачи любого рода</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;q&gt;</span> - Определяет краткую цитату</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;rule&gt;</span> - Определяет правила для обновления шаблонов</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;s&gt;</span> - 	Не поддерживается. Определяет зачеркнутый текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;samp&gt;</span> - Определяет образец программного кода</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;script&gt;</span> - Определяет сценарий (скрипт)</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;section&gt;</span> - Определяет раздел (секцию)</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;select&gt;</span> - Определяет список для выбора</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;small&gt;</span> - Определяет мелкий текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;source&gt;</span> - Определяет медиа-ресурсы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;span&gt;</span> - 	Определяет раздел в документе</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;strike&gt;</span> - Не поддерживается. Определяет зачеркнутый текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;strong&gt;</span> - Определяет выделенный жирный текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;style&gt;</span> - Определяет определение стиля</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;sub&gt;</span> - Определяет индексным текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;sup&gt;</span> - Определяет надстрочным текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;table&gt;</span> - 	Определяет таблицу</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;tbody&gt;</span> - 	Определяет тело таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;td&gt;</span> - Определяет ячейку таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;textarea&gt;</span> - Определяет область ввода текста</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;tfoot&gt;</span> - Определяет колонтитул таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;th&gt;</span> - Определяет заголовок ячейки таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;thead&gt;</span> - Определяет заголовок таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;time&gt;</span> - Определяет дату/время</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;title&gt;</span> - Определяет название документа</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;tr&gt;</span> - Определяет строку таблицы</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;tt&gt;</span> - Не поддерживается. Определяет телетайп текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;u&gt;</span> - Не поддерживается. Определяет подчеркнутый текст</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;ul&gt;</span> - Определяет неупорядоченный список</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;var&gt;</span> - Определяет переменную</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;video&gt;</span> - 	Определяет видео</p>
                    <p class="p-orange-two"><span class="orange-two">&lt;xmp&gt;</span> - Не поддерживается. Определяет выровненный текст</p>      
                    <div class="block-footer"></div>                  
                </div>
            </div>
            <div class="content" id="elm-8">
                <div class="block">
                    <h1>MySQL — свободная реляционная система управления базами данных</h1>
                    <p class="p-blue">Какие еще бывают базы данных: </p>
                    <ul>
                        <li>
                            <span class="blue">Реляционные базы данных (MySQL, Oracle DB, PostgreSQL.)</span>
                            Это самый популярный тип БД, в которых информация хранится в виде таблиц. 
                            В строках находится описание каждого отдельного свойства объекта, 
                            а столбцы нужны для извлечения определённых свойств из строки.
                            Таблицы могут быть взаимосвязаны.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Резидентные базы данных (Redis, Apache Ignite, Tarantool.)</span>
                            Сведения хранятся в оперативной памяти. Данные обрабатываются быстро, 
                            поэтому резидентные БД популярны там, где нужно обеспечить максимально короткое время отклика.
                            Они помогают управлять телекоммуникационным оборудованием, 
                            проводить торги в онлайн-режиме или Real-Time обслуживание. 
                            Базы in-memory поддерживают и быстрое написание, и быстрое чтение. 
                            В основном они работают с записями «ключ-значение», но также могут работать со столбцами.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Поисковые базы данных (Elastic.)</span>
                            Этот тип БД нужен для получения сведений через фильтр. 
                            Искать можно по любому введённому значению, в том числе по отдельным словам. 
                            Можно пользоваться полнотекстовым поиском. 
                            Поисковые базы данных хорошо масштабируются и удобны для хранения журналов, 
                            объёмных текстовых значений.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Базы данных с широкими столбцами (Cassandra, Google BigTable, HBase.)</span>
                            БД с широкими столбцами могут запрашивать большие объёмы данных быстрее, 
                            чем обычные реляционные. Сведения хранятся в виде записей «‎ключ-значение»‎ 
                            на жёстком диске или твёрдотельном накопителе. 
                            Базы данных с широкими столбцами позволяют выполнять быструю запись построчно и быстрое чтение по ключу.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Столбчатые базы данных (Clickhouse, Vertica.)</span>
                            В БД такого типа данные хранятся в столбцах, а не в строках. 
                            Получение доступа к содержимому осуществляется без помощи ключей. 
                            При использовании столбчатых баз данных используют пакетную вставку, 
                            чтобы можно было готовить информацию для быстрого чтения по столбцам. 
                            В столбчатых БД есть поддержка аналитики и возможность удобного масштабирования.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Документоориентированные базы данных (CouchDB, Couchbase, MongoDB)</span>
                            Если в реляционных БД для извлечения данных нужно объединять таблицы, 
                            то в этих базах отлично хранится несвязанная информация в больших объёмах. 
                            Они поддерживают JSON. 
                            Для любого ключа можно создать сложное значение и сразу включить всю структуру данных в одну запись. 
                            Выборка по запросу может содержать части множества документов без их полной загрузки в оперативную память.
                        </li>
                            </br>
                        <li>
                            <span class="blue">Графовые базы данных (OrientDB, Neo4j.)</span>
                            Данные хранятся в виде графов, то есть моделей с узлами и связями. 
                            Они достаточно гибкие, с логичной структурой. 
                            Узлы служат для хранения сущностей данных, а рёбра — для хранения взаимосвязей между сущностями, 
                            которыми можно управлять.
                        </li>
                    </ul>
                    <p class="p-blue">Основные операции:</p>
                    <ul>
                        <li>
                            <span class="blue">Типы данных: Числовые типы, Символьные (строковые), Текстовые и бинарные, Дата/время, JSON</span>
                                <br/>
                            <a class="link-blue" target="_blanc" href="https://selectel.ru/blog/tutorials/data-types-in-mysql/">Читать подробнее..</a>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Запрос SELECT (SELECT - ВЫБОР)</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов

# Примеры запросов:

    SELECT * FROM country;
    SELECT Code, Name, Continent FROM country;
    SELECT DISTINCT Continent FROM country;
    SELECT Code, Name, Continent FROM country;
    SELECT Code, Name, Continent FROM country LIMIT 5 OFFSET 5;
    SELECT Code, Name, Continent FROM country LIMIT 5,5;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Сортировка данных с ORDER BY</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым. 
# В последнем случае, сортировка будет происходить по алфавиту.

# Примеры запросов:

    SELECT Name, Population FROM country ORDER BY Population;
    SELECT Region, Population, Name FROM country ORDER BY Region, Population;
    SELECT Region, Population, Name FROM country ORDER BY 1, 2;
    SELECT Name, Population FROM country ORDER BY Population DESC;
    SELECT Name, Population FROM country ORDER BY Population ASC;
    SELECT Region, Population, Name FROM country ORDER BY Region DESC, Population;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Функции MySQL</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении

# Примеры запросов:

#https://dev.mysql.com/doc/refman/8.0/en/functions.html
#http://www.mysql.ru/docs/man/Functions.html

    SELECT CONCAT(Name, ', ', Continent, ', ', Region) AS full_name FROM country LIMIT 10;
    SELECT CONCAT_WS(', ', Name, Continent, Region) AS full_name FROM country LIMIT 10;
    SELECT Name, FORMAT(SurfaceArea, 1, 'de_DE') AS area_de, FORMAT(SurfaceArea, 1, 'ru_RU') AS area_ru, Population FROM country ORDER BY Population DESC LIMIT 10;
    SELECT Name, UCASE(Name) AS u1, LCASE(Name) AS l1 FROM country LIMIT 10;
    SELECT LTRIM('   test   ');
    SELECT RTRIM('   test   ');
    SELECT TRIM('   test   ');
    SELECT Name, SurfaceArea, Population, (Population / SurfaceArea) AS Density, CEIL(Population / SurfaceArea) AS Density2 FROM country ORDER BY Population DESC LIMIT 10;
    SELECT Name, SurfaceArea, Population, (Population / SurfaceArea) AS Density, FLOOR(Population / SurfaceArea) AS Density2 FROM country ORDER BY Population DESC LIMIT 10;
    SELECT Name, SurfaceArea, Population, (Population / SurfaceArea) AS Density, ROUND( (Population / SurfaceArea), 1) AS Density2 FROM country ORDER BY Population DESC LIMIT 10;
    SELECT NOW();
    SET lc_time_names = 'ru_RU';
    SELECT DATE_FORMAT(NOW(), '%d %M %Y');

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Объединение таблиц в MySQL - Подзапросы</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
 # country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении

# Примеры запросов:

    SELECT city.Name, (
    SELECT country.Name FROM country WHERE country.Code = city.CountryCode
        ) AS country
        FROM city;
                                        
    SELECT city.Name, country.Name AS country FROM city, country WHERE country.Code = city.CountryCode;
                                        
    SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id;
                                        
    SELECT Customers.FirstName, Products.ProductName, Orders.CreatedAt
        FROM Orders, Customers, Products
            WHERE Orders.CustomerId = Customers.Id AND Orders.ProductId = Products.Id;
                                                
    SELECT C.FirstName, P.ProductName, O.CreatedAt
        FROM Orders AS O, Customers AS C, Products AS P
            WHERE O.CustomerId = C.Id AND O.ProductId = P.Id;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Оператор INSERT в MySQL</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении
# INSERT - добавляет данных в БД в MySQL используется команда INSERT

# Примеры запросов:

#INSERT [INTO] имя_таблицы [(столбец1, столбец2, ... столбецN)] VALUES (значение1, значение2, ... значениеN)

    INSERT INTO Products (ProductName, Manufacturer, Price)
    VALUES ('SONY XPERIA', 'SONY');
    INSERT INTO Products (ProductName, Manufacturer, Price)
	VALUES ('SONY XPERIA2', 'SONY', 10), ('SONY XPERIA3', 'SONY', 20), ('SONY XPERIA4', 'SONY', 30);

    CREATE TABLE `Products_copy` (
	    `Id` INT(11) NOT NULL AUTO_INCREMENT,
	    `ProductName` VARCHAR(30) NOT NULL,
	    `Manufacturer` VARCHAR(20) NOT NULL,
	    `ProductCount` INT(11) NULL DEFAULT '0',
	    `Price` DECIMAL(10,0) NOT NULL DEFAULT '0',
	PRIMARY KEY (`Id`)
        )
    COLLATE='utf8_general_ci'
    ENGINE=InnoDB;

    INSERT INTO Products_copy (Id, ProductName, Manufacturer, ProductCount, Price)
	    SELECT Id, ProductName, Manufacturer, ProductCount, Price FROM Products;

    CREATE TABLE Products_copy AS SELECT * FROM Products;

    CREATE TABLE Products_copy (PRIMARY KEY (Id)) AS SELECT * FROM Products;

    CREATE TABLE Products_copy LIKE Products;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Операторы UPDATE и DELETE</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении
# INSERT - добавляет данных в БД в MySQL используется команда INSERT
# UPDATE - используется для обновления существующих записей в таблице в базе данных MySQL. Существует три синтаксиса для оператора UPDATE в зависимости от типа обновления, которое вы хотите выполнить
# DELETE - команда DELETE удаляет данные из БД

# Примеры запросов:

    CREATE TABLE Products_copy (Id INT AUTO_INCREMENT PRIMARY KEY) AS SELECT * FROM Products;
    UPDATE Products_copy SET Manufacturer = 'Sony' WHERE Id = 9;
    UPDATE Products_copy SET Manufacturer = 'Sony', ProductCount = NULL WHERE Id = 10;
    DELETE FROM Products_copy WHERE Id > 11;
    TRUNCATE TABLE Products_copy;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Создание, изменение и удаление таблиц в MySQL</span>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении
# INSERT - добавляет данных в БД в MySQL используется команда INSERT
# UPDATE - используется для обновления существующих записей в таблице в базе данных MySQL. Существует три синтаксиса для оператора UPDATE в зависимости от типа обновления, которое вы хотите выполнить
# DELETE - команда DELETE удаляет данные из БД
# CREATE TABLE - команда создает базу данных

# Примеры запросов:

    CREATE TABLE [IF NOT EXISTS] Products_copy
        (
	        Id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
	        ProductName VARCHAR(30) NOT NULL,
	        Manufacturer VARCHAR(20) NOT NULL,
	        ProductCount INT NULL DEFAULT '0',
	        Price DECIMAL(10,0) NOT NULL DEFAULT '0'
        );

            ALTER TABLE Products_copy MODIFY Manufacturer VARCHAR(255);
            ALTER TABLE Products_copy ADD test INT;
            ALTER TABLE Products_copy DROP COLUMN test;
            DROP TABLE Products_copy;

                                    </code>
                                </pre>
                            </p>
                        </li>
                        <li>
                            <span class="blue">Представления в MySQL (или вью - это виртуальная таблица, методанные в которой храница sql запрос)</span>
                            <p class="p-blue">
                                Такой подход используеться когда запросы слишком сложные, то есть на основе запроса содаеться предтавления
                            </p>
                            <p class="p-blue">
                                Второй вариант это защита данных.
                            </p>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении
# INSERT - добавляет данных в БД в MySQL используется команда INSERT
# UPDATE - используется для обновления существующих записей в таблице в базе данных MySQL. Существует три синтаксиса для оператора UPDATE в зависимости от типа обновления, которое вы хотите выполнить
# DELETE - команда DELETE удаляет данные из БД
# CREATE TABLE - команда создает базу данных
# CREATE VIEW - (представление или вьюха) не является физической таблицей, а скорее представляет собой виртуальную таблицу, созданную запросом, соединяющим одну или несколько таблиц.

# Примеры запросов:

    CREATE VIEW city_info AS
        SELECT city.Name AS city_name, country.Name AS country_name, country.Code, countrylanguage.Language 
            FROM country
                    JOIN city ON city.CountryCode = country.Code
                    JOIN countrylanguage ON countrylanguage.CountryCode = country.Code
                    WHERE countrylanguage.IsOfficial = 'T';
                                                                     
                    SELECT * FROM city_info;
                                    
                    DROP VIEW IF EXISTS city_info;

                                    </code>
                                </pre>
                            </p>
                        </li>
                            </br>
                        <li>
                            <span class="blue">Хранимые процедуры в MySQL</span>
                            <p class="p-blue">Хранимая процедура - это подпрограмма, она хранит имя, список параметров, запросы sql</p>
                            <p class="p-blue">Как правило это используеться для того что бы по какому то событию выполнять какие то sql команды</p>
                            <p>
                                <pre class="lang-php">
                                    <code>
# SELECT - выбрать
# * - все
# FROM - из
# country - название таблицы
# ; - завершение запроса
# DISTINCT - используется для указания на то, что следует работать только с уникальными значениями столбца
# LIMIT - позволяет вывести указанное число строк из таблицы. Оператор SQL LIMIT записывается всегда в конце запроса
# OFFSET - указывает количество строк, которые нужно пропустить, прежде чем начать возвращать строки из запроса
# Code, Name, Continent - названия столбцов
# ORDER BY - выполняет сортировку выходных значений. Оператор SQL ORDER BY можно применять как к числовым столбцам, так и к строковым
# В последнем случае, сортировка будет происходить по алфавиту
# ( ... ) - круглые скобки используются для задания порядка вычислений в выражении
# INSERT - добавляет данных в БД в MySQL используется команда INSERT
# UPDATE - используется для обновления существующих записей в таблице в базе данных MySQL. Существует три синтаксиса для оператора UPDATE в зависимости от типа обновления, которое вы хотите выполнить
# DELETE - команда DELETE удаляет данные из БД
# CREATE TABLE - команда создает базу данных
# CREATE VIEW - (представление или вьюха) не является физической таблицей, а скорее представляет собой виртуальную таблицу, созданную запросом, соединяющим одну или несколько таблиц.
# PROCEDURE - опредиляет процедуру которо йнужно присвоить имя

# Примеры запросов:

    DELIMITER //
        CREATE PROCEDURE test()
         BEGIN
	        SELECT 'Hello, I am a Procedure' AS hi;
        END //

        CALL test();

         DELIMITER //
            CREATE PROCEDURE city_info()
                BEGIN
	            SELECT city.Name AS city_name, country.Name AS country_name, country.Code, countrylanguage.Language 
	                FROM country
	                    JOIN city ON city.CountryCode = country.Code
	                    JOIN countrylanguage ON countrylanguage.CountryCode = country.Code
	                    WHERE countrylanguage.IsOfficial = 'T';   
                    END //

                    DROP PROCEDURE test;

                    DELIMITER //
                        CREATE PROCEDURE city_info(l INT)
                            BEGIN
                                SELECT city.Name AS city_name, country.Name AS country_name, country.Code, countrylanguage.Language 
                                FROM country
                                JOIN city ON city.CountryCode = country.Code
                                JOIN countrylanguage ON countrylanguage.CountryCode = country.Code
                                WHERE countrylanguage.IsOfficial = 'T' LIMIT l;
                            END //


                    CALL city_info(5)

                                    </code>
                                </pre>
                            </p>
                        </li>
                    </ul>
                    <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-9">
                <div class="block">ajax</div>
            </div>
            <div class="content" id="elm-10">
                <div class="block">
                    <h1>
                        JSON — текстовый формат обмена данными, основанный на JavaScript. 
                        Как и многие другие текстовые форматы, JSON легко читается людьми. 
                        Формат JSON был разработан Дугласом Крокфордом.
                    </h1>

                    <p>Пример для работы на PHP</p>

                    <p>
                        Функции работы с JSON.
                    </p>

                    <p>
                        <pre class="lang-php">
                            <code>
echo 'JSON - формат';

// У нас есть многомерный массив, с помощью функции мы преобразуем его в формат JSON.

$arr = [
  'fio' => 'Иван Иванов',
  'age' => '33',
  'site_url' => 'https://xsaxsa',
  'learn' => ['html','css','php']
];

// json_encode - кодирует
// json_decode - декодирует

// JSON_UNESCAPED_UNICODE - атрибут который преобразут спец символы кириллицы в приемлемый формат.

echo json_encode($arr, JSON_UNESCAPED_UNICODE);

// Пример обратной операции

$json = '{ "people":"Cидоров Никита", "adress":"Ленина 234", "mob": ["876945653456", "54665436353"]}';

$arr2 = json_decode($json, true);

echo '<pre>';
print_r($arr2);
echo '</pre>';

                            </code>
                        </pre>
                    </p>
                  <div class="block-footer"></div>
                </div>
            </div>
            <div class="content" id="elm-11">
                <div class="block">
                    <h1>
                        Объе́ктно-ориенти́рованное программи́рование (сокр. ООП) — методология программирования, 
                        основанная на представлении программы в виде совокупности взаимодействующих объектов, 
                        каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования
                    </h1>
                    <p class="p-blue-three">
                        Идеологически ООП — подход к программированию как к моделированию информационных объектов, 
                        решающий на новом уровне основную задачу структурного программирования: 
                        структурирование информации с точки зрения управляемости[2], 
                        что существенно улучшает управляемость самим процессом моделирования, что, 
                        в свою очередь, особенно важно при реализации крупных проектов.
                    </p>
                    <p class="p-blue-three">
                        Управляемость для иерархических систем предполагает минимизацию избыточности данных (аналогичную нормализации) 
                        и их целостность, поэтому созданное удобно управляемым — будет и удобно пониматься. 
                        Таким образом, через тактическую задачу управляемости решается стратегическая задача — транслировать понимание 
                        задачи программистом в наиболее удобную для дальнейшего использования форму.
                    </p>
                    <p class="p-blue-three">
                        Основные принципы структурирования в случае ООП связаны с различными аспектами базового понимания предметной задачи, 
                        которое требуется для оптимального управления соответствующей моделью:
                    </p>
                    <ul>
                        <li><span class="blue-three">абстракция</span> для выделения в моделируемом предмете важного для решения конкретной задачи по предмету, 
                            в конечном счёте — контекстное понимание предмета, формализуемое в виде класса;</li>
                            </br>
                        <li><span class="blue-three">инкапсуляция</span> для быстрой и безопасной организации собственно иерархической управляемости: 
                            чтобы было достаточно простой команды «что делать», без одновременного уточнения как именно делать, 
                            так как это уже другой уровень управления;</li>
                            </br>
                        <li><span class="blue-three">наследование</span> для быстрой и безопасной организации родственных понятий: чтобы было достаточно на каждом иерархическом 
                            шаге учитывать только изменения, не дублируя всё остальное, учтённое на предыдущих шагах;</li>
                            </br>
                        <li><span class="blue-three">полиморфизм</span> для определения точки, в которой единое управление лучше распараллелить
                            или наоборот — собрать воедино.</li>
                    </ul>
                    <p class="p-blue-three">Пример:</p>
                    <p>
                        <pre class="lang-php">
                            <code>

class Employee
        {
            private $first_name;
            private $last_name;
            private $age;
                                  
            public function __construct($first_name, $last_name, $age)
        {
            $this->first_name = $first_name;
            $this->last_name = $last_name;
            $this->age = $age;
        }
                                 
            public function getFirstName()
        {
            return $this->first_name;
        }
                                 
            public function getLastName()
        {
            return $this->last_name;
        }
                                 
            public function getAge()
        {
            return $this->age;
        }
}

                            </code>
                        </pre>
                    </p>
                    <p class="p-blue-three">Классы</p>
                    <p>
                        Класс - это шаблон, который представляет реальное понятие и определяет свойства и методы данного понятия.
                        В этом разделе мы обсудим базовую анатомию типичного класса PHP.
                    </p>
                    <p class="p-blue-three">Конструктор</p>
                    <p>Конструкторы</p>
                    <p>
                        Конструктор - это специальный метод класса, который вызывается автоматически при инстанцинации объекта. 
                        В следующих разделах мы увидим, как инстанцировать объекты, но сейчас вам нужно просто знать, что конструктор
                        используется для инициализации свойств объекта при создании объекта.
                    </p>
                    <p>
                        Вы можете определить конструктор с помощью метода __construct.
                    </p>
                    <p class="p-blue-three">Методы</p>
                    <p>
                        В большинстве случаев метода используются для доступа и управления свойствами объекта и выполнения связанных операций.
                    </p>
                    <p class="p-blue-three">Уровни доступа, методы они же функции</p>
                    <ul>
                        <li>public - к нему можно получить доступ из любого места вне класса. 
                            Значение открытого свойства можно изменить из любого участка вашего кода.</li>
                        <li>private - доступ к ним можно получить только из класса. Это означает, что вам нужно определить методы получения и установки, 
                            чтобы получить и установить значение этого свойства.</li>
                        <li>protected - к ним может обращаться тот же класс, который их определил, или классы, которые наследуют рассматриваемый класс.</li>
                    </ul>
                    <p class="p-blue-three">
                        Наследование:
                    </p>
                    <p>
                        Наследование является важным аспектом парадигмы объектно-ориентированного программирования, которая позволяет наследовать свойства и методы других классов, расширяя их.
                        Класс, который наследуется, называется родительским классом, а класс, который наследует другой класс, называется дочерним классом.  
                        Когда вы создаете экземпляр объекта дочернего класса, он также наследует свойства и методы родительского класса.
                    </p>
                    <p>
                        <pre class="lang-php">
                            <code>
class Person
{
    protected $name;
    protected $age;
                                 
    public function getName()
{
    return $this->name;
}
                                 
    public function setName($name)
{
    $this->name = $name;
}
                                 
    private function callToPrivateNameAndAge()
{
    return "{$this->name} is {$this->age} years old.";
}
                                 
    protected function callToProtectedNameAndAge()
{
    return "{$this->name} is {$this->age} years old.";
    }
}
                                 
    class Employee extends Person
{
    private $designation;
    private $salary;
                                 
    public function getAge()
{
    return $this->age;
}
                                 
    public function setAge($age)
{
    $this->age = $age;
}
                                 
    public function getDesignation()
{
    return $this->designation;
}
                                 
    public function setDesignation($designation)
{
    $this->designation = $designation;
}
                                 
    public function getSalary()
{
    return $this->salary;
}
                                 
    public function setSalary($salary)
{
    $this->salary = $salary;
}
                                 
    public function getNameAndAge()
{
    return $this->callToProtectedNameAndAge();
    }
}
                                 
$employee = new Employee();
                                 
$employee->setName('Bob Smith');
$employee->setAge(30);
$employee->setDesignation('Software Engineer');
$employee->setSalary('30K');
                                 
echo $employee->getName(); // prints 'Bob Smith'
echo $employee->getAge(); // prints '30'
echo $employee->getDesignation(); // prints 'Software Engineer'
echo $employee->getSalary(); // prints '30K'
echo $employee->getNameAndAge(); // prints 'Bob Smith is 30 years old.'
echo $employee->callToPrivateNameAndAge(); // produces 'Fatal Error'

                            </code>
                        </pre>
                    </p>
                    <p class="p-blue-three">Полиморфизм</p>
                    <p>Полиморфизм - еще одна важная концепция в мире объектно-ориентированного программирования, 
                       которая относится к способности по-разному обрабатывать объекты в зависимости от их типов данных.</p>
                    <p>Например, в контексте наследования, если дочерний класс хочет изменить поведение метода родительского класса, 
                       он может переопределить этот метод.  Это называется переопределением метода. 
                       Давайте быстро рассмотрим реальный пример, чтобы понять концепцию переопределения метода.</p>
                       <p>
                           <pre class="lang-php">
                               <code>
class Message
    {
    public function formatMessage($message)
    {
    return printf("<i>%s</i>", $message);
        }
    }
                                 
    class BoldMessage extends Message
        {
    public function formatMessage($message)
        {
    return printf("<b>%s</b>", $message);
        }
    }
                                 
    $message = new Message();
    $message->formatMessage('Hello World'); // prints '<i>Hello World</i>'
                                 
    $message = new BoldMessage();
    $message->formatMessage('Hello World'); // prints '<b>Hello World</b>'                
                               </code>
                           </pre>
                       </p>
                       <p>Как видите, мы изменили поведение метода formatMessage, переопределив его в классе BoldMessage. 
                          Важно то, что сообщение форматируется по-разному в зависимости от типа объекта, будь то экземпляр родительского 
                          или дочернего класса.
                       </p>
                       <p>
                          (Некоторые объектно-ориентированные языки также имеют своего рода перезагрузку методов, 
                          которая позволяет определять несколько методов класса с одним и тем же именем, 
                          но с разным количеством аргументов. Это не поддерживается напрямую в PHP, 
                          но существуют несколько обходных путей для достижения аналогичной функциональности.)
                       </p>
                       <p class="p-blue-three">Магические функци</p>
                       <p>Это специальные методы, которые переопределяют действие PHP по умолчанию, когда над объектом выполняются определённые действия.</p>
                       <ul>
                           <li><span class="blue-three">__construct()</span> - позволяет объявлять методы-конструкторы. Классы, в которых объявлен метод-конструктор, 
                               будут вызывать этот метод при каждом создании нового объекта, так что это может оказаться полезным, 
                               например, для инициализации какого-либо состояния объекта перед его использованием.</li>
                               </br>
                           <li><span class="blue-three">__destruct()</span> - будет вызван при освобождении всех ссылок на определённый объект или при завершении скрипта 
                            (порядок выполнения деструкторов не гарантируется</li>
                               </br>
                           <li><span class="blue-three">__call()</span> - запускается при вызове недоступных методов в контексте объект.</li>
                               </br>
                           <li><span class="blue-three">__callStatic()</span> - запускается при вызове недоступных методов в статическом контексте.</li>
                               </br>
                           <li><span class="blue-three">__get()</span> - будет выполнен при чтении данных из недоступных (защищённых или приватных) или несуществующих свойств.</li>
                               </br>
                           <li><span class="blue-three">__set()</span> - будет выполнен при записи данных в недоступные (защищённые или приватные) или несуществующие свойства.</li>
                               </br>
                           <li><span class="blue-three">__isset()</span> - будет выполнен при использовании isset() или empty() на недоступных (защищённых или приватных) или несуществующих свойствах.</li>
                               </br>
                           <li><span class="blue-three">__unset()</span> - будет выполнен при вызове unset() на недоступном (защищённом или приватном) или несуществующем свойстве.</li>
                               </br>
                           <li><span class="blue-three">__sleep()</span> - состоит в завершении работы над данными, ждущими обработки или других подобных задач очистки. Кроме того, этот метод может быть полезен, когда есть очень большие объекты, которые нет необходимости полностью сохранять.</li>
                               </br>
                           <li><span class="blue-three">__wakeup()</span> - заключается в восстановлении любых соединений с базой данных, которые могли быть потеряны во время операции сериализации и выполнения других операций повторной инициализации.</li>
                               </br>
                           <li><span class="blue-three">__serialize()</span> - проверяет, есть ли в классе функция с магическим именем __serialize(). Если да, функция выполняется перед любой сериализацией. Она должна создать и вернуть ассоциативный массив пар ключ/значение, которые представляют сериализованную форму объекта. Если массив не возвращён, будет выдано TypeError.</li>
                               </br>
                           <li><span class="blue-three">__unserialize()</span> - проверяет наличие магической функции __unserialize(). Если функция присутствует, ей будет передан восстановленный массив, который был возвращён из __serialize(). Затем он может восстановить свойства объекта из этого массива соответствующим образом.</li>
                               </br>
                           <li><span class="blue-three">__toString()</span> - позволяет классу решать, как он должен реагировать при преобразовании в строку. Например, что вывести при выполнении echo $obj;.</li>
                               </br>
                           <li><span class="blue-three">__invoke()</span> - вызывается, когда скрипт пытается выполнить объект как функцию.</li>
                               </br>
                           <li><span class="blue-three">__set_state()</span> - Этот статический метод вызывается для тех классов, которые экспортируются функцией var_export().
                                               Единственным параметром этого метода является массив, содержащий экспортируемые свойства в виде ['property' => value, ...].</li>
                                </br>
                           <li><span class="blue-three">__clone()</span> - После завершения клонирования, если метод __clone() определён, то будет вызван метод __clone() вновь созданного объекта для возможного изменения всех необходимых свойств.</li>
                                </br>
                           <li><span class="blue-three">__debugInfo()</span> - Этот метод вызывается функцией var_dump(), когда необходимо вывести список свойств объекта. Если этот метод не определён, тогда будут выведены все свойства объекта c модификаторами public, protected и private.</li>
                       </ul>
                       <p>Подробнее:</p>
                       <a target="_blank" href="https://www.php.net/manual/ru/language.oop5.magic.php">Читать</a>
                    <div class="block-footer"></div>
                </div>              
            </div>
        </div>
    </div>
    <script src="js/jquery.min.js"></script>
    <script src="js/overlayScrollbars.min.js"></script>
    <script src="js/prism.js"></script>
    <script src="js/script.js"></script>
</body>
</html>